import { ConferenceConfig } from "./conferenceSharedModels.js";
/**
 * active participant, the user has already authenticated
 */
export class Participant {
    participantId = ""; //generated by server to keep track of connections
    userName = ""; //username for the user, unique, used to login ie from a database
    displayName = ""; //display name for the user
    socket = undefined; //websocket connection
    conferenceRoom = undefined; //reference to a conf room
}
export class ConferenceRoom {
    conferenceId; //primary key from database
    title; //title of the room
    conferenceRoomId; //conference server roomid generated
    conferenceToken = ""; //provided by our conferencing server    
    participants = [];
    isClosed = false;
    leader;
    // configs
    config = new ConferenceConfig();
    //rooms
    roomId; //roomid from room server
    roomToken = ""; //provided by the rooms server
    get confType() {
        return this.config.type;
    }
    onParticipantRemove;
    onParticipantAdd;
    onClosed;
    // Timers
    timerIdMaxDuration = undefined;
    //executes when room is created and no participants has joined
    timerIdNoParticipants = undefined;
    startTimer() {
        if (this.config.timeOutMaxDurationSecs > 0) {
            this.timerIdMaxDuration = setTimeout(async () => {
                console.log("timeOutMaxDurationSecs timed out");
                this.close();
            }, this.config.timeOutMaxDurationSecs * 1000);
        }
        if (this.config.timeOutNoParticipantsSecs > 0) {
            this.timerIdNoParticipants = setTimeout(async () => {
                console.log("timerIdNoParticipantsSecs timed out");
                this.close();
            }, this.config.timeOutNoParticipantsSecs * 1000);
        }
        return true;
    }
    addParticipant(participant) {
        if (this.isClosed) {
            console.error("conference is closed.");
            return false;
        }
        if (this.config.maxParticipants > 2 && this.participants.length >= this.config.maxParticipants) {
            console.error("max participants reached");
            return false;
        }
        if (participant.conferenceRoom) {
            console.error("already in conference room");
            return false;
        }
        //if no leader, and userName matches assign as leader
        if (this.config.leaderUserName) {
            if (!this.leader && this.config.leaderUserName == participant.userName) {
                console.log("leaderUserName match, leader assigned: " + participant.userName, participant.participantId);
                this.leader = participant;
            }
        }
        else {
            if (!this.leader && this.participants.length == 0) {
                console.log("leader assigned: " + participant.userName, participant.participantId);
                this.leader = participant;
            }
        }
        console.log("addParticipant", participant.participantId);
        this.participants.push(participant);
        participant.conferenceRoom = this;
        if (this.onParticipantAdd) {
            this.onParticipantAdd(participant);
        }
        console.log("conf participants total: " + this.participants.length);
        //if a participants is added clear timerIdNoParticipantsSecs 
        if (this.timerIdNoParticipants) {
            clearTimeout(this.timerIdNoParticipants);
        }
        return true;
    }
    removeParticipant(participant) {
        console.log("removeParticipant ", participant.participantId);
        if (participant.conferenceRoom == this) {
            let idx = this.participants.findIndex(p => p.participantId == participant.participantId);
            if (idx > -1) {
                this.participants.splice(idx, 1);
            }
            participant.conferenceRoom = undefined;
        }
        if (this.onParticipantRemove) {
            this.onParticipantRemove(participant);
        }
        console.log("conf participants total: " + this.participants.length);
        if (this.participants.length == 0) {
            console.log("conference closed no participants");
            this.close();
            return;
        }
        if (this.config.closeConferenceOnLeaderExit && this.leader && this.leader == participant) {
            console.log("conference closed no leader exit");
            this.close();
            return;
        }
    }
    /**
     * Broadcasts a message to all active participants except the specified one
     * @param excludeParticipant Participant to exclude from broadcast
     * @param msg Message to broadcast
     */
    broadCastExcept(excludeParticipant, msg) {
        for (let p of this.participants) {
            if (p !== excludeParticipant && p.socket) {
                try {
                    p.socket.send(JSON.stringify(msg));
                }
                catch (error) {
                    console.error(`Failed to send message to participant ${p.participantId}`, error);
                }
            }
        }
    }
    getParticipantsExcept(except) {
        return this.participants.filter(p => p != except);
    }
    async broadCastAll(msg) {
        for (let p of this.participants.values()) {
            try {
                p.socket.send(JSON.stringify(msg));
            }
            catch (exp) {
                console.error(exp);
            }
        }
    }
    close() {
        this.isClosed = true;
        if (this.timerIdMaxDuration) {
            clearTimeout(this.timerIdMaxDuration);
        }
        if (this.onClosed) {
            this.onClosed();
        }
    }
}
