import { WebSocket } from "ws";

/**
 * active participant, the user has already authenticated
 */
export class Participant {
    participantId: string = ""; //generated by server to keep track of connections
    userName : string = ""; //username for the user, unique, used to login ie from a database
    displayName: string = ""; //display name for the user
    socket?: WebSocket = null; //websocket connection
    conferenceRoom?: ConferenceRoom = null; //reference to a conf room
}

export class ConferenceConfig {
    dateStart = new Date();
    dateEnd?: Date = null;
    maxParticipants: number = 2;
    allowConferenceVideo = true;
    allowConferenceAudio = true;

    allowParticipantVideo = true;
    allowParticpantAudio = true;

    inviteOnly = false; //anyone can join or by invite only
}

export class ConferenceRoom {
    externalId: number; //primary key from database
    conferenceRoomId: string; //conference server roomid generated
    participants: Participant[] = [];
    timerId?: NodeJS.Timeout = null;
    isClosed = false;
    leader?: Participant;

    // configs
    config: ConferenceConfig = new ConferenceConfig();

    onParticipantRemove: ((participant: Participant) => void);
    onParticipantAdd: (participant: Participant) => void;
    onClosed: () => void;

    startTimer(): boolean {

        let diffInMs = 0;
        if (this.config.dateStart && this.config.dateEnd) {
            diffInMs = this.config.dateEnd.getTime() - this.config.dateStart.getTime();
        }

        if (diffInMs > 0) {
            this.timerId = setTimeout(async () => {
                console.log("room timed out");
                this.close();
            }, diffInMs);
        }

        return true;
    }

    addParticipant(participant: Participant): boolean {
        if (this.isClosed) {
            console.error("conference is closed.");
            return false;
        }

        if (this.config.maxParticipants > 2 && this.participants.length >= this.config.maxParticipants) {
            console.error("max participants reached");
            return false;
        }

        if (participant.conferenceRoom) {
            console.error("already in conference room");
            return false;
        }

        //first participant is the leader
        if (this.participants.length == 0) {
            this.leader = participant;
        }

        console.log("addParticipant", participant.participantId);
        this.participants.push(participant);
        participant.conferenceRoom = this;

        if (this.onParticipantAdd) {
            this.onParticipantAdd(participant);
        }
        console.log("conf participants total: " + this.participants.length);

        return true;
    }

    removeParticipant(participant: Participant): void {
        console.log("removeParticipant ", participant.participantId);
        if (participant.conferenceRoom == this) {
            let idx = this.participants.findIndex(p => p.participantId == participant.participantId);
            if (idx > -1) {
                this.participants.splice(idx, 1);
            }
            participant.conferenceRoom = null;
        }

        if (this.onParticipantRemove) {
            this.onParticipantRemove(participant);
        }

        console.log("conf participants total: " + this.participants.length);

    }

    /**
     * Broadcasts a message to all active participants except the specified one
     * @param excludeParticipant Participant to exclude from broadcast
     * @param msg Message to broadcast
     */
    broadCastExcept(excludeParticipant: Participant, msg: any) {
        for (let p of this.participants) {
            if (p !== excludeParticipant && p.socket) {
                try {
                    p.socket.send(JSON.stringify(msg));
                } catch (error) {
                    console.error(`Failed to send message to participant ${p.participantId}`, error);
                }
            }
        }
    }

    getParticipantsExcept(except: Participant) {
        return this.participants.filter(p => p != except);
    }

    async broadCastAll(msg: any) {
        for (let p of this.participants.values()) {
            try {
                p.socket.send(JSON.stringify(msg));
            } catch (exp) {
                console.error(exp);
            }
        }
    }
   
    close() {

        this.isClosed = true;

        if (this.timerId) {
            clearTimeout(this.timerId);
        }

        if (this.onClosed) {
            this.onClosed();
        }
    }
}