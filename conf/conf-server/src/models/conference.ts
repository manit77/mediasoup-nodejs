import { ConferenceConfig, conferenceType, ParticipantRole } from "@conf/conf-models";
import { SocketConnection } from "./socketConnection.js";
import { consoleLog, consoleWarn } from "../utils/utils.js";
import { AuthUserRoles } from "@rooms/rooms-models";

/**
 * active participant
 */
export class Participant {

    participantId: string = ""; //generated by server to keep track of connections
    username: string = ""; //username for the user, unique, used to login ie from a database
    displayName: string = ""; //display name for the user
    conference?: Conference = null; //reference to a conf room
    role: ParticipantRole | string = ParticipantRole.guest;
    clientData: {} = {}; //passed down from the user login or the query string from a client    
    connection: SocketConnection;
    participantGroup = "";
    conferenceGroup = "";
    dateCreated = new Date();

    constructor() {

    }
}

export type conferenceStatus = "none" | "initializing" | "ready" | "closed";

export class Conference {
    id: string;
    externalId: string;
    participantGroup: string;    
    presenter?: Participant;
    leader?: Participant;

    timeoutId: any;
    intervalIdTimeoutId: any;

    /**
     * default 12 hours
     */
    timeoutSecs: number = 12 * 60;
    roomName: string;
    roomURI: string;
    roomId: string;
    roomRtpCapabilities: any;
    participants: Map<string, Participant> = new Map();
    status: conferenceStatus = "none";
    config = new ConferenceConfig();
    confType: conferenceType = "p2p"

    /**
     * default 45 secs
     */
    minParticipantsTimeoutSec = 45;
    /**
     * default 1
     */
    minParticipants = 1;
    minParticipantsTimerId: any;

    /**
    * timer when no user or admin role in conf,
    * default 60 secs
    */
    noUserTimeoutSec = 60;
    noUserTimeoutId: any;

    onReadyListeners: (() => void)[] = [];
    dateCreated: Date;

    onClose = (conf: Conference, participants: Participant[], reason: string) => { };
    onInterval = (conf: Conference) => { };
    onNewParticipant = (part: Participant) => { };

    constructor() {
        this.dateCreated = new Date();
    }

    addOnReadyListener(cb: () => void) {
        if (this.status == "ready") {
            cb();
            return;
        }
        this.onReadyListeners.push(cb);
    }

    removeOnReadyListener(callback: () => void): void {
        this.onReadyListeners = this.onReadyListeners.filter(listener => listener !== callback);
    }

    updateStatus(status: conferenceStatus) {
        consoleLog(`updateStatus ${status}`);

        this.status = status;

        if (status == "ready") {
            for (let cb of this.onReadyListeners) {
                cb();
            }
            this.onReadyListeners = [];
        }
    }

    removeParticipant(id: string) {
        consoleLog("removeParticipant");

        let part = this.participants.get(id);
        if (part) {
            part.conference = null;
            this.participants.delete(id);
            consoleLog("participant removed");

            if (this.leader == part) {
                this.leader = null;
            }

            if (this.presenter == part) {
                this.presenter = null;
            }
        }

        if (this.participants.size == 0) {
            consoleLog("closing room, no participants.");
            this.close("no participants");
            return;
        }

        this.startTimerMinParticipants();

        this.startTimerNoUser();
    }

    addParticipant(part: Participant): boolean {
        consoleLog(`addParticipant. ${part.participantId} ${part.displayName}`);

        if (this.participants.has(part.participantId)) {
            console.error("participant already exists");
            return false;
        }

        let arrParts = [...this.participants.values()];
        let usersCount = arrParts.filter(p => p.role == ParticipantRole.admin || p.role == ParticipantRole.user).length;
        let guestCount = arrParts.filter(p => p.role == ParticipantRole.guest).length;

        if (this.config.usersMax > 0 && usersCount >= this.config.usersMax) {
            console.error(`max users reached.`);
            return false;
        }

        if (this.config.guestsMax > 0 && guestCount >= this.config.guestsMax) {
            console.error(`max guests reached.`);
            return false;
        }

        this.participants.set(part.participantId, part);
        part.conference = this;

        if (!this.leader && this.config.leaderTrackingId === part.participantId) {
            consoleWarn(`leader set ${this.roomName} ${part.displayName}`);
            this.leader = part;
        }

        if (this.minParticipants >= this.participants.size) {
            if (this.minParticipantsTimerId) {
                clearTimeout(this.minParticipantsTimerId);
            }
        }

        if (part.role === AuthUserRoles.admin || part.role === AuthUserRoles.user) {
            if (this.noUserTimeoutId) {
                clearTimeout(this.noUserTimeoutId);
            }
        }

        this.onNewParticipant(part);

        return true;
    }

    close(reason: string) {
        consoleLog(`conference close. id: ${this.id}, roomName: ${this.roomName}, confType: ${this.confType}, reason: ${reason}`);

        if (this.status === "closed") {
            consoleLog("conference already closed.");
            return;
        }

        this.status = "closed";

        let existingParticipants = [...this.participants.values()];

        this.presenter = null;
        this.leader = null;

        for (let part of this.participants.values()) {
            part.conference = null;
        }
        this.participants.clear();

        this.onReadyListeners = [];

        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }

        if (this.minParticipantsTimerId) {
            clearTimeout(this.minParticipantsTimerId);
            this.minParticipantsTimerId = null;
        }

        if (this.noUserTimeoutId) {
            clearTimeout(this.noUserTimeoutId);
            this.noUserTimeoutId = null;
        }
        if (this.intervalIdTimeoutId) {
            clearTimeout(this.intervalIdTimeoutId);
            this.intervalIdTimeoutId = null;
        }
        this.onClose(this, existingParticipants, reason);
    }

    /**
     * starts the room timer for max room duration
     */
    startTimers() {
        consoleLog(`startTimers`);

        this.startConferenceTimer();
        this.startTimerMinParticipants();
        this.startInterval();
    }

    private startConferenceTimer() {
        consoleLog(`startConferenceTimer, timeout in ${this.timeoutSecs}`);

        if (this.timeoutSecs > 0) {
            consoleWarn(`shutting down conf ${this.roomName} in ${Math.round(this.timeoutSecs / 60)} min.`);
            this.timeoutId = setTimeout(() => { this.close("room timeout."); }, this.timeoutSecs * 1000);
            consoleLog(`startTimer, timer started in ${this.timeoutSecs}`);
            return;
        }
        consoleWarn(`not timelimit for room ${this.roomName}`);
    }

    /**
     * starts a timer for min participants
     * this triggers a scenario there is one person in a room.
     * @param timeoutSeconds 
     */
    private startTimerMinParticipants() {
        consoleLog(`startTimerMinParticipants, timeout in ${this.minParticipantsTimeoutSec}`);

        if (this.minParticipantsTimerId) {
            clearTimeout(this.minParticipantsTimerId);
        }

        if (this.participants.size >= this.minParticipants) {
            return;
        }

        if (this.minParticipants > 0 && this.minParticipantsTimeoutSec > 0) {
            consoleLog(`startTimerMinParticipants started ${this.minParticipants}`);
            consoleWarn(`shutting down conf ${this.roomName} in ${Math.round(this.minParticipantsTimeoutSec / 60)} min. if minParticipants of ${this.minParticipants} not met.`);

            this.minParticipantsTimerId = setTimeout(() => {
                if (this.participants.size < this.minParticipants) {
                    consoleLog("TimerMinParticipants executed.");
                    this.close("minimum participants reached.");
                }
            }, this.minParticipantsTimeoutSec * 1000);
        }
    }

    private startInterval() {
        consoleLog(`startInterval`);

        if (this.status == "closed") {
            return;
        }

        if (this.intervalIdTimeoutId) {
            clearTimeout(this.intervalIdTimeoutId);
        }

        this.intervalIdTimeoutId = setTimeout(() => {
            this.onInterval(this);
            this.startInterval();
            //}, 60 * 1000);
        }, 10 * 1000);

    }

    /**
     * if there are no authorized users, only guests close the room on timeout
     * this timer allows a user to reconnect if disconnected from a conference.
     * @returns 
     */
    private startTimerNoUser() {

        if (this.noUserTimeoutId) {
            clearTimeout(this.noUserTimeoutId);
        }

        if (this.noUserTimeoutSec <= 0) {
            return;
        }

        let userCount = [...this.participants.values()].filter(p => p.role == AuthUserRoles.user || p.role === AuthUserRoles.admin).length;
        if (userCount == 0) {
            this.noUserTimeoutId = setTimeout(() => {
                let userCount = [...this.participants.values()].filter(p => p.role == AuthUserRoles.user || p.role === AuthUserRoles.admin);
                if (userCount) {
                    this.close("No admin, closing room.");
                }
            }, this.noUserTimeoutSec * 1000);
        }
    }

}