import { ConferenceRoomConfig, conferenceType, ParticipantRole } from "@conf/conf-models";
import { WebSocket } from "ws";
import { AbstractEventHandler } from "../utils/evenHandler.js";
import { consoleLog, consoleWarn } from "../utils/utils.js";

export interface IAuthPayload {
    username: string,
    role: ParticipantRole | string,
}

type onSocketTimeout = (conn: SocketConnection) => void;

export class SocketConnection {

    socketTimeoutId: any;
    ws: WebSocket;
    timeoutSecs: number;
    participantId: string;
    eventHandlers: onSocketTimeout[] = [];
    dateOfLastMsg : Date = new Date();

    constructor(webSocket: WebSocket, socketTimeoutSecs: number) {
        this.ws = webSocket;
        this.timeoutSecs = socketTimeoutSecs;
    }

    dispose() {
        consoleLog(`SocketConnection dispose()`);
        this.eventHandlers = [];

        if (this.ws) {
            this.ws.close();
            this.ws = null;
            consoleLog(`SocketConnection ws close`);
        }
    }

    addEventHandlers(cb: onSocketTimeout) {
        this.eventHandlers.push(cb);
    }

    restartSocketTimeout = () => {
        consoleLog(`restartSocketTimeout`);

        if (this.socketTimeoutId) {
            clearTimeout(this.socketTimeoutId);
            this.socketTimeoutId = null;
        }

        if(this.timeoutSecs <= 0) {
             consoleWarn(`not timeout set for this connection.`);
            return;
        }

        consoleLog(`SocketConnection socketTimeout started:`, this.timeoutSecs);
        this.socketTimeoutId = setTimeout(() => {
            consoleLog(`SocketConnection socketTimeout reached ${this.eventHandlers.length}`);
            for (let cb of this.eventHandlers) {
                consoleWarn(`SocketConnection socketTimeout fire event`);
                cb(this);
            }
        }, this.timeoutSecs * 1000);
    }

}

/**
 * active participant
 */
export class Participant {

    participantId: string = ""; //generated by server to keep track of connections
    username: string = ""; //username for the user, unique, used to login ie from a database
    displayName: string = ""; //display name for the user
    conference?: Conference = undefined; //reference to a conf room
    role: ParticipantRole | string = ParticipantRole.guest;
    clientData: {} = {}; //passed down from the user login or the query string from a client    
    connection: SocketConnection;

    constructor() {

    }
}

export type conferenceStatus = "none" | "initializing" | "ready" | "closed";

export class Conference {
    id: string;
    externalId: string;
    timeoutId: any;
    timeoutSecs: number = 0;
    roomName: string;
    roomURI: string;
    roomId: string;
    roomToken: string;
    roomRtpCapabilities: any;
    participants: Map<string, Participant> = new Map();
    status: conferenceStatus = "none";
    config = new ConferenceRoomConfig();
    confType: conferenceType = "p2p"

    minParticipants = 0;
    minParticipantsTimerId: any;

    onReadyListeners: (() => void)[] = [];

    onClose: (conf: Conference, participants: Participant[], reason: string) => void;

    constructor() {

    }

    addOnReadyListener(cb: () => void) {
        if (this.status == "ready") {
            cb();
            return;
        }
        this.onReadyListeners.push(cb);
    }

    removeOnReadyListener(callback: () => void): void {
        this.onReadyListeners = this.onReadyListeners.filter(listener => listener !== callback);
    }

    updateStatus(status: conferenceStatus) {
        consoleLog(`updateStatus ${status}`);

        this.status = status;

        if (status == "ready") {
            for (let cb of this.onReadyListeners) {
                cb();
            }
            this.onReadyListeners = [];
        }
    }

    removeParticipant(id: string) {
        consoleLog("removeParticipant");

        let part = this.participants.get(id);
        if (part) {
            part.conference = null;
            this.participants.delete(id);
            consoleLog("participant removed");
        }

        if (this.participants.size == 0) {
            consoleLog("closing room, no participants.");
            this.close();
        }
    }

    addParticipant(part: Participant): boolean {
        consoleLog(`addParticipant. ${part.participantId} ${part.displayName}`);

        if (this.participants.has(part.participantId)) {
            console.error("participant already exists");
            return false;
        }

        let arrParts = [...this.participants.values()];
        let usersCount = arrParts.filter(p => p.role == ParticipantRole.admin || p.role == ParticipantRole.user).length;
        let guestCount = arrParts.filter(p => p.role == ParticipantRole.guest).length;

        if (this.config.usersMax > 0 && usersCount >= this.config.usersMax) {
            console.error(`max users reached.`);
            return false;
        }

        if (this.config.guestsMax > 0 && guestCount >= this.config.guestsMax) {
            console.error(`max guests reached.`);
            return false;
        }

        this.participants.set(part.participantId, part);
        part.conference = this;

        if (this.minParticipants >= this.participants.size) {
            if (this.minParticipantsTimerId) {
                clearTimeout(this.minParticipantsTimerId);
            }
        }
        return true;
    }

    close(reason: string = "") {
        consoleLog(`conference close. ${this.id} reason: ${reason}`);

        if (this.status === "closed") {
            consoleLog("conference already closed.");
            return;
        }

        this.status = "closed";

        let existingParticipants = [...this.participants.values()];

        for (let part of this.participants.values()) {
            part.conference = null;
        }
        this.participants.clear();

        this.onReadyListeners = [];
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }

        if (this.minParticipantsTimerId) {
            clearTimeout(this.minParticipantsTimerId);
            this.minParticipantsTimerId = null;
        }

        if (this.onClose) {
            this.onClose(this, existingParticipants, reason);
        }
    }

    /**
     * starts the room timer for max room duration
     */
    startTimer() {
        if (this.timeoutSecs > 0) {
            this.timeoutId = setTimeout(() => { this.close(); }, this.timeoutSecs * 1000);
        }
    }

    /**
     * starts a timer for min participants
     * @param timeoutSeconds 
     */
    startTimerMinParticipants(timeoutSeconds: number) {
        consoleLog("startTimerMinParticipants");

        if (this.minParticipantsTimerId) {
            clearTimeout(this.minParticipantsTimerId);
        }

        if (this.minParticipants > 0) {
            consoleLog(`startTimerMinParticipants started ${this.minParticipants}`);
            this.minParticipantsTimerId = setTimeout(() => {
                consoleLog("TimerMinParticipants executed.");
                this.close();
            }, timeoutSeconds * 1000);
        }
    }

}