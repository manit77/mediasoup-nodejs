import { ConferenceConfig, conferenceType, ParticipantRole } from "@conf/conf-models";
import { WebSocket } from "ws";
import { AbstractEventHandler } from "../utils/evenHandler.js";
import { consoleLog, consoleWarn } from "../utils/utils.js";

export interface IAuthPayload {
    username: string,
    participantGroup: string,
    role: ParticipantRole | string,
}

type onSocketTimeout = (conn: SocketConnection) => void;

export class SocketConnection {

    
    ws: WebSocket;
    
    /**
     * time allowed until registration
     */
    timeoutSecs: number;
    socketTimeoutId: any;

    participantId: string;
    username: string;
    eventHandlers: onSocketTimeout[] = [];
    dateOfLastMsg: Date = new Date();
    dateCreated = new Date();
    
    pingInterval: any;
    lastPong : number;
    ips: string[] = [];

    constructor(webSocket: WebSocket, socketTimeoutSecs: number) {
        this.ws = webSocket;
        this.timeoutSecs = socketTimeoutSecs;
    }

    dispose() {
        consoleLog(`SocketConnection dispose()`);
        this.eventHandlers = [];

        if (this.ws) {
            this.ws.close();
            this.ws = null;
            consoleLog(`SocketConnection ws close`);
        }
    }

    addEventHandlers(cb: onSocketTimeout) {
        this.eventHandlers.push(cb);
    }

    clearSocketTimeout = () => {
        consoleLog(`clearSocketTimeout`);

        if (this.socketTimeoutId) {
            clearTimeout(this.socketTimeoutId);
            this.socketTimeoutId = null;
        }
    };

    restartSocketTimeout = () => {
        consoleLog(`restartSocketTimeout`);

        if (this.socketTimeoutId) {
            clearTimeout(this.socketTimeoutId);
            this.socketTimeoutId = null;
        }

        if (this.timeoutSecs <= 0) {
            consoleWarn(`not timeout set for this connection.`);
            return;
        }

        consoleLog(`SocketConnection socketTimeout started:`, this.timeoutSecs);
        consoleWarn(`Socket has ${this.timeoutSecs} to register.`);
        this.socketTimeoutId = setTimeout(() => {
            consoleLog(`SocketConnection socketTimeout reached ${this.eventHandlers.length}`);
            for (let cb of this.eventHandlers) {
                consoleWarn(`SocketConnection socketTimeout fire event`);
                cb(this);
            }
        }, this.timeoutSecs * 1000);
    };

}

/**
 * active participant
 */
export class Participant {

    participantId: string = ""; //generated by server to keep track of connections
    username: string = ""; //username for the user, unique, used to login ie from a database
    displayName: string = ""; //display name for the user
    conference?: Conference = undefined; //reference to a conf room
    role: ParticipantRole | string = ParticipantRole.guest;
    clientData: {} = {}; //passed down from the user login or the query string from a client    
    connection: SocketConnection;
    participantGroup = "";
    dateCreated = new Date();

    constructor() {

    }
}

export type conferenceStatus = "none" | "initializing" | "ready" | "closed";

export class Conference {
    id: string;
    externalId: string;
    participantGroup: string;
    presenter: Participant;

    timeoutId: any;
    timeoutSecs: number = 0;
    roomName: string;
    roomURI: string;
    roomId: string;
    roomToken: string;
    roomRtpCapabilities: any;
    participants: Map<string, Participant> = new Map();
    status: conferenceStatus = "none";
    config = new ConferenceConfig();
    confType: conferenceType = "p2p"

    minParticipantsTimeoutSeconds = 30;
    minParticipants = 0;
    minParticipantsTimerId: any;

    onReadyListeners: (() => void)[] = [];
    dateCreated: Date;

    onClose: (conf: Conference, participants: Participant[], reason: string) => void;

    constructor() {
        this.dateCreated = new Date();
    }

    addOnReadyListener(cb: () => void) {
        if (this.status == "ready") {
            cb();
            return;
        }
        this.onReadyListeners.push(cb);
    }

    removeOnReadyListener(callback: () => void): void {
        this.onReadyListeners = this.onReadyListeners.filter(listener => listener !== callback);
    }

    updateStatus(status: conferenceStatus) {
        consoleLog(`updateStatus ${status}`);

        this.status = status;

        if (status == "ready") {
            for (let cb of this.onReadyListeners) {
                cb();
            }
            this.onReadyListeners = [];
        }
    }

    removeParticipant(id: string) {
        consoleLog("removeParticipant");

        let part = this.participants.get(id);
        if (part) {
            part.conference = null;
            this.participants.delete(id);
            consoleLog("participant removed");
        }

        this.startTimerMinParticipants();

        if (this.participants.size == 0) {
            consoleLog("closing room, no participants.");
            this.close("no participants");
        }
    }

    addParticipant(part: Participant): boolean {
        consoleLog(`addParticipant. ${part.participantId} ${part.displayName}`);

        if (this.participants.has(part.participantId)) {
            console.error("participant already exists");
            return false;
        }

        let arrParts = [...this.participants.values()];
        let usersCount = arrParts.filter(p => p.role == ParticipantRole.admin || p.role == ParticipantRole.user).length;
        let guestCount = arrParts.filter(p => p.role == ParticipantRole.guest).length;

        if (this.config.usersMax > 0 && usersCount >= this.config.usersMax) {
            console.error(`max users reached.`);
            return false;
        }

        if (this.config.guestsMax > 0 && guestCount >= this.config.guestsMax) {
            console.error(`max guests reached.`);
            return false;
        }

        this.participants.set(part.participantId, part);
        part.conference = this;

        if (this.minParticipants >= this.participants.size) {
            if (this.minParticipantsTimerId) {
                clearTimeout(this.minParticipantsTimerId);
            }
        }
        return true;
    }

    close(reason: string) {
        consoleLog(`conference close. id: ${this.id}, roomName: ${this.roomName}, confType: ${this.confType}, reason: ${reason}`);

        if (this.status === "closed") {
            consoleLog("conference already closed.");
            return;
        }

        this.status = "closed";

        let existingParticipants = [...this.participants.values()];

        this.presenter = null;

        for (let part of this.participants.values()) {
            part.conference = null;
        }
        this.participants.clear();

        this.onReadyListeners = [];

        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }

        if (this.minParticipantsTimerId) {
            clearTimeout(this.minParticipantsTimerId);
            this.minParticipantsTimerId = null;
        }

        if (this.onClose) {
            this.onClose(this, existingParticipants, reason);
        }
    }

    /**
     * starts the room timer for max room duration
     */
    startTimers() {
        consoleLog(`startTimers`);
        this.startConferenceTimer();
        this.startTimerMinParticipants()
    }

    private startConferenceTimer() {
        consoleLog(`startConferenceTimer, timeout in ${this.timeoutSecs}`);
        if (this.timeoutSecs > 0) {
            consoleWarn(`shutting down conf ${this.roomName} in ${Math.round(this.timeoutSecs / 60)} min.`);
            this.timeoutId = setTimeout(() => { this.close("room timedout."); }, this.timeoutSecs * 1000);
            consoleLog(`startTimer, timer started in ${this.timeoutSecs}`);
            return;
        }
        consoleWarn(`not timelimit for room ${this.roomName}`);
    }


    /**
     * starts a timer for min participants
     * @param timeoutSeconds 
     */
    private startTimerMinParticipants() {
        consoleLog(`startTimerMinParticipants, timeout in ${this.minParticipantsTimeoutSeconds}`);
        this.minParticipantsTimeoutSeconds = this.minParticipantsTimeoutSeconds;

        if (this.minParticipantsTimerId) {
            clearTimeout(this.minParticipantsTimerId);
        }

        if (this.participants.size >= this.minParticipants) {
            return;
        }

        if (this.minParticipants > 0 && this.minParticipantsTimeoutSeconds > 0) {
            consoleLog(`startTimerMinParticipants started ${this.minParticipants}`);
            consoleWarn(`shutting down conf ${this.roomName} in ${Math.round(this.minParticipantsTimeoutSeconds / 60)} min. if minParticipants of ${this.minParticipants} not met.`);

            this.minParticipantsTimerId = setTimeout(() => {
                if (this.participants.size < this.minParticipants) {
                    consoleLog("TimerMinParticipants executed.");
                    this.close("minimum participants reached.");
                }
            }, this.minParticipantsTimeoutSeconds * 1000);
        }
    }

}